using System;
using APlusMalware.ByteLogic;
using APlusMalware.LogicGraph;
using UnityEngine;

namespace APlusMalware.LogicLaserPlugin
{
    public class LogicSplitter : MachineEntity, ILogicReceiver
    {
        private const Int32 FaceCount = 6;

        private Byte _face;
        private readonly LogicNode<Byte> _node;

        private readonly Byte[] _targetFaces = new Byte[FaceCount];

        private readonly SByte[] _xOffsets = new SByte[FaceCount / 2];
        private readonly SByte[] _yOffsets = new SByte[FaceCount / 2];
        private readonly SByte[] _zOffsets = new SByte[FaceCount / 2];

        public LogicSplitter(Segment segment, Int64 x, Int64 y, Int64 z, UInt16 cubeType, Byte flags, UInt16 value)
            : base( eSegmentEntity.LaserSplitter, SpawnableObjectEnum.LaserSplitter, x, y, z, cubeType, flags, value, Vector3.zero, segment)
        {
            mbNeedsLowFrequencyUpdate = true;
            _node = new Splitter();
            LogicManager.instance.mGraph.AddNode(_node);
            UpdateFaces(flags);
        }

        public override void OnDelete()
        {
            _node.DisconnectAll();
            LogicManager.instance.mGraph.RemoveNode(_node);
            base.OnDelete();
        }

        public override void OnUpdateRotation(Byte flags)
        {
            base.OnUpdateRotation(flags);
            UpdateFaces(flags);
        }

        public override void LowFrequencyUpdate()
        {
            Int32 k = -1;
            for (Int32 i = 0; i < FaceCount / 2; i++)
            {
                for (Int32 j = 1; j > -2; j-=2)
                {
                    k++;
                    if (k == 5)
                        continue; // Skip over the back face since it's our input
                    // Get and check the block at the position
                    Int64 targetX = mnX + _xOffsets[i] * j;
                    Int64 targetY = mnY + _xOffsets[i] * j;
                    Int64 targetZ = mnZ + _xOffsets[i] * j;

                    Segment segment = AttemptGetSegment(targetX, targetY, targetZ);
                    if (segment == null)
                        continue; // Ignore this one and check the other blocks

                    UInt16 cubeType = segment.GetCube(targetX, targetY, targetZ);

                    ILogicReciever logicReciever;
                    Int32 inputIndex;
                    if (CubeHelper.HasEntity(cubeType)
                        && (logicReciever = segment.SearchEntity(targetX, targetY, targetZ) as ILogicReciever) != null
                        && (inputIndex = logicReciever.FindFaceInputIndex(_targetFaces[k])) != -1)
                    {
                        // There is a connectable logic node at the target location
                        var targetNode = logicReciever.GetLogicNode();
                        if (_node.OutNodes[k] == targetNode)
                            continue; // The current node is the same, no changes needed

                        // The node is not the same, so remove the old node and connect to the new one.
                        _node.DisconnectFromHead(k);
                        _node.ConnectToHead(k, targetNode, inputIndex);
                    }
                    else
                    {
                        // No connectable logic node at the target location, make sure we're disconnected
                        _node.DisconnectFromHead(k);
                    }
                }
            }
        }

        public SByte FindFaceInputIndex(Byte face)
        {
            if (face == _face)
                return 0;
            return -1;
        }

        public LogicNode<Byte> GetLogicNode()
        {
            return _node;
        }

        private void UpdateFaces(Byte flags)
        {
            Byte topFace = Utils.CalcTopFace(flags);
            Byte leftFace = Utils.CalcLeftFace(flags);
            Byte frontFace = Utils.CalcFrontFace(flags);

            _face = Utils.CalcOppositeFace(frontFace); // The back face

            Vector3 topVector = CubeHelper.GetDirectionVector(topFace);
            _targetFaces[0] = Utils.CalcOppositeFace(topFace);
            _targetFaces[1] = topFace;
            _xOffsets[0] = (SByte)topVector.x;
            _yOffsets[0] = (SByte)topVector.y;
            _zOffsets[0] = (SByte)topVector.z;

            Vector3 leftVector = CubeHelper.GetDirectionVector(leftFace);
            _targetFaces[2] = Utils.CalcOppositeFace(leftFace);
            _targetFaces[3] = leftFace;
            _xOffsets[1] = (SByte)leftVector.x;
            _yOffsets[1] = (SByte)leftVector.y;
            _zOffsets[1] = (SByte)leftVector.z;

            Vector3 frontVector = CubeHelper.GetDirectionVector(frontFace);
            _targetFaces[3] = Utils.CalcOppositeFace(frontFace);
            _targetFaces[4] = frontFace;
            _xOffsets[2] = (SByte)frontVector.x;
            _yOffsets[2] = (SByte)frontVector.y;
            _zOffsets[2] = (SByte)frontVector.z;
        }
    }
}
