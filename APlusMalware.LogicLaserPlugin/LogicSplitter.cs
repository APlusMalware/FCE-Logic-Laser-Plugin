using System;
using System.Linq;
using APlusMalware.ByteLogic;
using APlusMalware.LogicGraph;
using UnityEngine;

namespace APlusMalware.LogicLaserPlugin
{
    public class LogicSplitter : MachineEntity, ILogicReceiver
    {
        private const Int32 FaceCount = 6;

        private Byte _direction;
        private readonly LogicNode<Byte> _node;

        private readonly Byte[] _targetDirections = new Byte[FaceCount];

        private readonly SByte[] _xOffsets = new SByte[FaceCount / 2];
        private readonly SByte[] _yOffsets = new SByte[FaceCount / 2];
        private readonly SByte[] _zOffsets = new SByte[FaceCount / 2];

        public LogicSplitter(Segment segment, Int64 x, Int64 y, Int64 z, UInt16 cubeType, Byte flags, UInt16 value)
            : base( eSegmentEntity.Mod, SpawnableObjectEnum.LaserSplitter, x, y, z, cubeType, flags, value, Vector3.zero, segment)
        {
            mbNeedsLowFrequencyUpdate = true;
            _node = new Splitter();
            LogicManager.Instance.Graph.AddNode(_node);
            UpdateFaces(flags);
        }

        public override String GetPopupText()
        {
            String inputs = String.Join(", ", _node.InputValues.Select(i => i.ToString()).ToArray());
            String outputs = String.Join(", ", _node.OutputValues.Select(i => i.ToString()).ToArray());
            return $"Logic Splitter\nInput: {inputs}\nOutput: {outputs}";
        }

        public override void OnDelete()
        {
            _node.DisconnectAll();
            LogicManager.Instance.Graph.RemoveNode(_node);
            base.OnDelete();
        }

        public override void OnUpdateRotation(Byte flags)
        {
            base.OnUpdateRotation(flags);
            UpdateFaces(flags);
            _node.DisconnectAll();
        }

        public override void LowFrequencyUpdate()
        {
            Int32 k = -1;
            for (Int32 i = 0; i < FaceCount / 2; i++)
            {
                for (Int32 j = 1; j > -2; j-=2)
                {
                    k++;
                    if (k == 5)
                        continue; // Skip over the back direction since it's our input
                    // Get and check the block at the position
                    Int64 targetX = mnX + _xOffsets[i] * j;
                    Int64 targetY = mnY + _yOffsets[i] * j;
                    Int64 targetZ = mnZ + _zOffsets[i] * j;

                    Segment segment = AttemptGetSegment(targetX, targetY, targetZ);
                    if (segment == null)
                        continue; // Ignore this one and check the other blocks

                    UInt16 cubeType = segment.GetCube(targetX, targetY, targetZ);

                    ILogicReceiver logicReciever;
                    Int32 inputIndex;
                    if (CubeHelper.HasEntity(cubeType)
                        && (logicReciever = segment.SearchEntity(targetX, targetY, targetZ) as ILogicReceiver) != null
                        && (inputIndex = logicReciever.FindFaceInputIndex(_targetDirections[k])) != -1)
                    {
                        if (logicReciever == this)
                        {
                            Debug.LogError($"Laser Splitter connecting to itself? Loop vars: {i} {j} {k} Target coords: {targetX} {targetY} {targetZ}");
                            continue;
                        }

                        // There is a connectable logic node at the target location
                        var targetNode = logicReciever.GetLogicNode();
                        if (_node.OutNodes[k] == targetNode)
                            continue; // The current node is the same, no changes needed
                        
                        // The node is not the same, so remove the old node and connect to the new one.
                        _node.DisconnectFromHead(k);

                        if (!targetNode.IsInputActive(inputIndex))
                        {
                            try
                            {
                                _node.ConnectToHead(k, targetNode, inputIndex);
                            }
                            catch (InputEdgeAlreadyActiveException ex)
                            {
                                Debug.LogWarning(
                                    $"Splitter attempted to connect to index that was already in use! Loop vars: {i} {j} {k}\n" +
                                    $"\nTarget type: {targetNode.GetType()} inindex: {inputIndex} Active input count: {targetNode.ActiveInputCount}" +
                                    "\nException: " + ex);
                            }
                        }
                    }
                    else
                    {
                        // No connectable logic node at the target location, make sure we're disconnected
                        _node.DisconnectFromHead(k);
                    }
                }
            }
        }

        public SByte FindFaceInputIndex(Byte direction)
        {
            if (direction == _direction)
                return 0;
            return -1;
        }

        public LogicNode<Byte> GetLogicNode()
        {
            return _node;
        }

        private void UpdateFaces(Byte flags)
        {
            Byte topDirection = Utils.CalcTopDirection(flags);
            Byte leftDirection = Utils.CalcLeftDirection(flags);
            Byte frontDirection = Utils.CalcFrontDirection(flags);

            _direction = Utils.CalcOppositeDirection(frontDirection); // The back direction

            Vector3 topVector = CubeHelper.GetDirectionVector(topDirection);
            _targetDirections[0] = Utils.CalcOppositeDirection(topDirection);
            _targetDirections[1] = topDirection;
            _xOffsets[0] = (SByte)topVector.x;
            _yOffsets[0] = (SByte)(-topVector.y); // Get direction vector returns incorrectly negative y and z values
            _zOffsets[0] = (SByte)(-topVector.z);

            Vector3 leftVector = CubeHelper.GetDirectionVector(leftDirection);
            _targetDirections[2] = Utils.CalcOppositeDirection(leftDirection);
            _targetDirections[3] = leftDirection;
            _xOffsets[1] = (SByte)leftVector.x;
            _yOffsets[1] = (SByte)(-leftVector.y);
            _zOffsets[1] = (SByte)(-leftVector.z);

            Vector3 frontVector = CubeHelper.GetDirectionVector(frontDirection);
            _targetDirections[4] = Utils.CalcOppositeDirection(frontDirection);
            _targetDirections[5] = frontDirection;
            _xOffsets[2] = (SByte)frontVector.x;
            _yOffsets[2] = (SByte)(-frontVector.y);
            _zOffsets[2] = (SByte)(-frontVector.z);
        }
    }
}
