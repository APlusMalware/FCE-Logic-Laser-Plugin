using System;
using System.Linq;
using APlusMalware.ByteLogic;
using APlusMalware.LogicGraph;
using UnityEngine;

namespace APlusMalware.LogicLaserPlugin
{
    public abstract class LogicSensor : MachineEntity, ILogicReceiver
    {
        private static readonly Int32 OutIndex = 0;

        private Byte _targetDirection;

        private SByte _sourceXOffset;
        private SByte _sourceYOffset;
        private SByte _sourceZOffset;

        private readonly OnlyOutput _node;
        private Boolean _addedToGraph;

        protected LogicSensor(Segment segment, Int64 x, Int64 y, Int64 z, UInt16 cubeType, Byte flags, UInt16 value)
            : base(eSegmentEntity.Mod, SpawnableObjectEnum.ResearchStation, x, y, z, cubeType, flags, value, Vector3.zero, segment)
        {
            mbNeedsLowFrequencyUpdate = true;
            _node = new OnlyOutput();
            UpdateFaces(flags);
        }

        public String SensorName
        {
            get { return Utils.GetTerrainDataValueEntry(mCube, mValue)?.Name ?? Utils.GetTerrainDataEntry(mCube).Name; }
        }

        public sbyte FindFaceInputIndex(Byte direction)
        {
            return -1;
        }

        public LogicNode<Byte> GetLogicNode()
        {
            return _node;
        }

        public override String GetPopupText()
        {
            String outputs = String.Join(", ", _node.OutputValues.Select(i => i.ToString()).ToArray());
            return $"{SensorName}\nOutput: {outputs}";
        }

        public override void OnDelete()
        {
            _node.DisconnectAll();
            LogicManager.Instance.Graph.RemoveNode(_node);
            base.OnDelete();
        }

        public override void OnUpdateRotation(Byte flags)
        {
            base.OnUpdateRotation(flags);
            UpdateFaces(flags);
            _node.DisconnectAll();
        }

        public override void LowFrequencyUpdate()
        {
            if (!_addedToGraph)
            {
                LogicManager.Instance.Graph.AddNode(_node);
                _addedToGraph = true;
            }

            UpdateFromSource();
            UpdateTarget();
        }

        protected abstract Byte CalculateOutput(SegmentEntity entity, UInt16 data);

        private void UpdateTarget()
        {
            Int64 targetX = mnX - _sourceXOffset;
            Int64 targetY = mnY - _sourceYOffset;
            Int64 targetZ = mnZ - _sourceZOffset;
            Segment segment = AttemptGetSegment(targetX, targetY, targetZ);
            if (segment == null)
                return;
            UInt16 cubeType = segment.GetCube(targetX, targetY, targetZ);

            ILogicReceiver logicReciever;
            Int32 inputIndex;
            if (CubeHelper.HasEntity(cubeType)
                && (logicReciever = segment.SearchEntity(targetX, targetY, targetZ) as ILogicReceiver) != null
                && (inputIndex = logicReciever.FindFaceInputIndex(_targetDirection)) != -1)
            {
                // There is a connectable logic node at the target location
                var targetNode = logicReciever.GetLogicNode();
                if (_node.OutNodes[OutIndex] == targetNode)
                    return;
                
                // The node is not the same, so remove the old node and connect to the new one.
                _node.DisconnectFromHead(OutIndex);

                if (!targetNode.IsInputActive(inputIndex))
                {
                    try
                    {
                        _node.ConnectToHead(OutIndex, targetNode, inputIndex);
                    }
                    catch (InputEdgeAlreadyActiveException ex)
                    {
                        Debug.LogWarning(
                            "Sensor attempted to connect to index that was already in use!\n" +
                            $"\nTarget type: {targetNode.GetType()} inindex: {inputIndex} Active input count: {targetNode.ActiveInputCount}" +
                            "\nException: " + ex);
                    }
                }

                // Else, the current node is the same, no changes needed
            }
            else
            {
                // No connectable logic node at the target location, make sure we're disconnected
                _node.DisconnectFromHead(OutIndex);
            }
        }

        private void UpdateFromSource()
        {
            Int64 sourceX = mnX + _sourceXOffset;
            Int64 sourceY = mnY + _sourceYOffset;
            Int64 sourceZ = mnZ + _sourceZOffset;
            Segment segment = AttemptGetSegment(sourceX, sourceY, sourceZ);
            if (segment == null)
                return;
            UInt16 cubeType = segment.GetCube(sourceX, sourceY, sourceZ);

            if (CubeHelper.HasEntity(cubeType))
            {
                SegmentEntity entity = segment.SearchEntity(sourceX, sourceY, sourceZ);
                Byte output = CalculateOutput(entity, segment.GetCubeData(sourceX, sourceY, sourceZ).mValue);
                _node.SetOutput(output);
            }
        }

        private void UpdateFaces(Byte flags)
        {
            _targetDirection = Utils.CalcBottomDirection(flags);
            Vector3 vector = Vector3.Normalize(SegmentCustomRenderer.GetRotationQuaternion(flags) * Vector3.down);
            _sourceXOffset = (SByte)vector.x;
            _sourceYOffset = (SByte)vector.y;
            _sourceZOffset = (SByte)vector.z;
        }
    }
}
