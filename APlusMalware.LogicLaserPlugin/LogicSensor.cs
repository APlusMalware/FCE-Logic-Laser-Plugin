using System;
using APlusMalware.ByteLogic;
using APlusMalware.LogicGraph;
using UnityEngine;

namespace APlusMalware.LogicLaserPlugin
{
    public class LogicSensor : MachineEntity, ILogicReceiver
    {
        private static readonly Int32 OutIndex = 0;

        private Byte _targetFace;

        private SByte _sourceXOffset;
        private SByte _sourceYOffset;
        private SByte _sourceZOffset;

        private readonly OnlyOutput _node; 
        public LogicSensor(Segment segment, Int64 x, Int64 y, Int64 z, UInt16 cubeType, Byte flags, UInt16 value)
            : base( eSegmentEntity.LaserReceptor, SpawnableObjectEnum.ResearchStation, x, y, z, cubeType, flags, value, Vector3.zero, segment)
        {
            mbNeedsLowFrequencyUpdate = true;
            _node = new OnlyOutput();
            LogicManager.instance.mGraph.AddNode(_node);
            UpdateFaces(flags);
        }

        public sbyte FindFaceInputIndex(Byte face)
        {
            return -1;
        }

        public LogicNode<Byte> GetLogicNode()
        {
            return _node;
        }

        public override void OnDelete()
        {
            _node.DisconnectAll();
            LogicManager.instance.mGraph.RemoveNode(_node);
            base.OnDelete();
        }

        public override void OnUpdateRotation(Byte flags)
        {
            base.OnUpdateRotation(flags);
            UpdateFaces(flags);
            _node.DisconnectAll();
        }

        public override void LowFrequencyUpdate()
        {
            UpdateFromSource();
            UpdateTarget();
        }

        private void UpdateTarget()
        {
            Int64 targetX = mnX - _sourceXOffset;
            Int64 targetY = mnY - _sourceYOffset;
            Int64 targetZ = mnZ - _sourceZOffset;
            Segment segment = AttemptGetSegment(targetX, targetY, targetZ);
            if (segment == null)
                return;
            UInt16 cubeType = segment.GetCube(targetX, targetY, targetZ);

            ILogicReciever logicReciever;
            Int32 inputIndex;
            if (CubeHelper.HasEntity(cubeType)
                && (logicReciever = segment.SearchEntity(targetX, targetY, targetZ) as ILogicReciever) != null
                && (inputIndex = logicReciever.FindFaceInputIndex(_targetFace)) != -1)
            {
                // There is a connectable logic node at the target location
                var targetNode = logicReciever.GetLogicNode();
                if (_node.OutNodes[OutIndex] != targetNode)
                {
                    // The node is not the same, so remove the old node and connect to the new one.
                    _node.DisconnectFromHead(OutIndex);
                    _node.ConnectToHead(OutIndex, targetNode, inputIndex);
                }
                // Else, the current node is the same, no changes needed
            }
            else
            {
                // No connectable logic node at the target location, make sure we're disconnected
                _node.DisconnectFromHead(OutIndex);
            }
        }

        private void UpdateFromSource()
        {
            Int64 sourceX = mnX + _sourceXOffset;
            Int64 sourceY = mnY + _sourceYOffset;
            Int64 sourceZ = mnZ + _sourceZOffset;
            Segment segment = AttemptGetSegment(sourceX, sourceY, sourceZ);
            if (segment == null)
                return;
            UInt16 cubeType = segment.GetCube(sourceX, sourceY, sourceZ);

            if (CubeHelper.HasEntity(cubeType))
            {
                Byte output;
                SegmentEntity entity = segment.SearchEntity(sourceX, sourceY, sourceZ);
                switch (mValue)
                {
                    case 0:
                        output = UpdateForPowerConsumer(entity);
                        break;
                    case 1:
                        output = UpdateForConveyor(entity);
                        break;
                    case 2:
                        output = UpdateForStorage(entity);
                        break;
                    case 3:
                        output = UpdateForCentralPowerHub(entity);
                        break;
                    case 4:
                        output = UpdateForLift(entity);
                        break;
                    case 5:
                        output = UpdateForThreatScanner(entity);
                        break;
                    case 6:
                        output = UpdateForMinecartTrack(entity);
                        break;
                    case 7:
                        output = UpdateForCrystal(entity);
                        break;
                    default:
                        output = 0;
                        break;
                }
                _node.SetOutput(output);
            }
        }

        private Byte UpdateForPowerConsumer(SegmentEntity entity)
        {
            PowerConsumerInterface powerConsumerInterface = entity as PowerConsumerInterface;
            if (powerConsumerInterface != null)
            {
                Double remainingPower = Math.Round(powerConsumerInterface.GetRemainingPowerCapacity(), MidpointRounding.AwayFromZero);
                Double maxPower = Math.Round(powerConsumerInterface.GetMaxPower(), MidpointRounding.AwayFromZero);
                return (Byte) ((1f - remainingPower / maxPower) * 255f);
            }
            return 0;
        }

        private Byte UpdateForConveyor(SegmentEntity entity)
        {
            return 0;
        }

        private Byte UpdateForStorage(SegmentEntity entity)
        {
            return 0;
        }

        private Byte UpdateForCentralPowerHub(SegmentEntity entity)
        {
            return 0;
        }

        private Byte UpdateForLift(SegmentEntity entity)
        {
            return 0;
        }

        private Byte UpdateForThreatScanner(SegmentEntity entity)
        {
            if (entity is ThreatScanner)
                return (Byte)((1f - MobSpawnManager.mrTDCountDown / 3600f) * 255f);
            return 0;
        }

        private Byte UpdateForMinecartTrack(SegmentEntity entity)
        {
            return 0;
        }

        private Byte UpdateForCrystal(SegmentEntity entity)
        {
            CrystalEntity crystalEntity = entity as CrystalEntity;
            Int32 period = 1;
            if (crystalEntity != null)
            {
                switch (crystalEntity.mValue)
                {
                    case 0:
                        period = 2;
                        break;
                    case 1:
                        period = 3;
                        break;
                    case 2:
                        period = 5;
                        break;
                    case 3:
                        period = 7;
                        break;
                    case 4:
                        period = 11;
                        break;
                    case 5:
                        period = 13;
                        break;
                }
            }
            return LowFrequencyThread.mnThreadedUpdates % period != 0 ? (Byte) 0 : (Byte) 255;
        }

        private void UpdateFaces(Byte flags)
        {
            _targetFace = Utils.CalcBottomFace(flags);
            Vector3 vector = Vector3.Normalize(SegmentCustomRenderer.GetRotationQuaternion(flags) * Vector3.down);
            _sourceXOffset = (SByte)vector.x;
            _sourceYOffset = (SByte)vector.y;
            _sourceZOffset = (SByte)vector.z;
        }
    }
}
