using System;
using APlusMalware.LogicGraph;
using UnityEngine;

namespace APlusMalware.LogicLaserPlugin
{
    public abstract class LaserLogicBase : MachineEntity, ILogicReceiver
    {
        private static readonly Int32 MaxSearchDist = 64;
        private static readonly Int32 MinSearchDist = 1;
        private static readonly Int32 OutIndex = 0;


        private readonly LogicNode<Byte> _node;
        private Int32 _searchDist = 1;
        private Int32 _foundDist = Int32.MaxValue;
        private Boolean _found;
        private SByte _xOffset;
        private SByte _yOffset;
        private SByte _zOffset;
        private Byte _targetDirection;
        private Byte _output;

        private GameObject _beam;
        private GameObject _beamImpact;
        private Light _impactLight;
        private Vector3 _forwards;
        private Vector3 _impactPosition;
        private Single _beamLength;
        private Boolean _linkedToGameObject;

        protected LaserLogicBase(eSegmentEntity segmentEntity, SpawnableObjectEnum spawnableObject, Int64 x, Int64 y,
            Int64 z, UInt16 cube, Byte flags, UInt16 value, Segment segment, LogicNode<Byte> node)
            : base(segmentEntity, spawnableObject, x, y, z, cube, flags, value, Vector3.zero, segment)
        {
            _node = node;

            mbNeedsLowFrequencyUpdate = true;
            mbNeedsUnityUpdate = true;

            UpdateRotation(flags);

            LogicManager.Instance.Graph.AddNode(node);
        }

        public override void OnDelete()
        {
            ResetLogic();
            LogicManager.Instance.Graph.RemoveNode(_node);
            base.OnDelete();
        }

        public override void OnUpdateRotation(byte flags)
        {
            base.OnUpdateRotation(flags);
            UpdateRotation(flags);
            _searchDist = MinSearchDist;
            ResetLogic();
        }

        public override Boolean ShouldSave()
        {
            return true;
        }

        public override Boolean ShouldNetworkUpdate()
        {
            return true;
        }

        public override void DropGameObject()
        {
            _linkedToGameObject = false;
            base.DropGameObject();
        }

        private void ResetLogic()
        {
            _node.DisconnectAll();
        }

        public abstract SByte FindFaceInputIndex(Byte direction);

        public LogicNode<Byte> GetLogicNode()
        {
            return _node;
        }

        public override void LowFrequencyUpdate()
        {
            UpdatePlayerDistanceInfo();

            Int64 targetX = mnX + _xOffset*_searchDist;
            Int64 targetY = mnY + _yOffset*_searchDist;
            Int64 targetZ = mnZ + _zOffset*_searchDist;

            if (_searchDist > _foundDist)
            {
                // Uh oh, we've gone past the target, which means it's disappeared. Make sure we're disconnected from it.
                _node.DisconnectFromHead(OutIndex);
                _found = false;
            }

            if (_node.OutputValues.Length > 0)
                _output = _node.OutputValues[0];

            Segment segment = AttemptGetSegment(targetX, targetY, targetZ);
            if (segment == null)
                return; // We'll try again later.

            UInt16 cubeType = segment.GetCube(targetX, targetY, targetZ);

            ILogicReceiver logicReciever;
            Int32 inputIndex;
            if (CubeHelper.HasEntity(cubeType)
                && (logicReciever = segment.SearchEntity(targetX, targetY, targetZ) as ILogicReceiver) != null
                && (inputIndex = logicReciever.FindFaceInputIndex(_targetDirection)) != -1)
            {
                var targetNode = logicReciever.GetLogicNode();

                if (!targetNode.IsInputActive(inputIndex) && _node.OutNodes[OutIndex] != targetNode)
                {
                    // Disconnect and reconnect if the target input is not active or the node is different than previously
                    // The node we found is not the same as the old node

                    if (_searchDist > _foundDist)
                    {
                        // ERROR: This shouldn't happen. We went past the old _foundDist and found something else?
                        Debug.LogWarning("Logic Laser search went past _foundDist? _foundDist: " + _foundDist +
                                         "_searchDist" + _searchDist);
                    }
                    // We've found a different node, so connect to it instead.
                    // Disconnect from logic node at _foundDist and connect to the one at _searchDist.
                    _node.DisconnectFromHead(OutIndex);
                    try
                    {
                        _node.ConnectToHead(OutIndex, targetNode, inputIndex);
                        _foundDist = _searchDist;
                        _found = true;
                        _impactPosition = WorldScript.instance.mPlayerFrustrum.GetCoordsToUnity(targetX, targetY, targetZ);
                    }
                    catch (InputEdgeAlreadyActiveException ex)
                    {
                        Debug.LogWarning($"Laser attempted to connect to index that was already in use! Distance: {_searchDist}\n" +
                            $"\nTarget type: {targetNode.GetType()} inindex: {inputIndex} Active input count: {targetNode.ActiveInputCount}" +
                            "\nException: " + ex);
                    }
                }
                // Else, we've found what we were looking for, don't do anything else

                // Reset the search
                _searchDist = MinSearchDist;
            }
            else if (CubeHelper.IsCubeSolid(cubeType) && !CubeHelper.IsCubeGlass(cubeType) ||
                     _searchDist >= MaxSearchDist || CubeHelper.HasEntity(cubeType))
            {
                // We hit a wall or the max range, reset the search and disconnect from target node
                _searchDist = MinSearchDist;
                _found = false;
                _node.DisconnectFromHead(OutIndex);
            }
            else
            {
                // Non solid or glass block, increment the search.
                _searchDist++;
            }
        }

        public override void UnityUpdate()
        {
            bool justLinked = false;
            if (!_linkedToGameObject)
            {
                if (mWrapper == null || !mWrapper.mbHasGameObject)
                {
                    return;
                }
                if (mWrapper.mGameObjectList == null)
                {
                    Debug.LogError("Logic Laser missing game object #0?");
                }
                if (mWrapper.mGameObjectList[0].gameObject == null)
                {
                    Debug.LogError("Logic Laser missing game object #0 (GO)?");
                }
                _impactLight =
                    mWrapper.mGameObjectList[0].gameObject.transform.Search("Laser Impact").GetComponent<Light>();
                Transform transform = mWrapper.mGameObjectList[0].gameObject.transform.Search("Laser");
                if (transform == null)
                {
                    Debug.LogError("Logic Laser can't find Transform!");
                }
                _beam = transform.gameObject;
                if (_beam == null)
                {
                    Debug.LogError("Logic Laser can't find Beam!");
                }
                _beamImpact = mWrapper.mGameObjectList[0].gameObject.transform.Search("Laser Impact").gameObject;
                if (_beamImpact == null)
                {
                    Debug.LogError("Logic Laser can't find Beam Impact!");
                }
                _linkedToGameObject = true;
                justLinked = true;
            }

            _impactLight.enabled = mDistanceToPlayer < 32f;

            Boolean shouldBeamShow = !(mVectorToPlayer.y > 128f || mVectorToPlayer.y < -128f);

            if (_found && mSegment.mbOutOfView)
            {
                Int64 targetX = mnX + _xOffset*_foundDist;
                Int64 targetY = mnY + _yOffset* _foundDist;
                Int64 targetZ = mnZ + _zOffset* _foundDist;

                Segment segment = AttemptGetSegment(targetX, targetY, targetZ);
                Segment segment2 = AttemptGetSegment(targetX/2L + mnX/2L, targetY/2L + mnY/2L, targetZ/2L + mnZ/2L);
                if (segment == null || segment2 == null)
                {
                    shouldBeamShow = false;
                }
                else if (segment.mbOutOfView && segment2.mbOutOfView)
                {
                    shouldBeamShow = false;
                }
            }

            _beam.SetActive(shouldBeamShow);
            
            Int32 beamTargetDistance = _found ? _foundDist : _searchDist;

            if (_beamLength != beamTargetDistance || justLinked)
            {
                Single num = beamTargetDistance - _beamLength;
                if (num < 0.1f)
                {
                    _beamLength = beamTargetDistance;
                }
                else
                {
                    _beamLength += num*Time.deltaTime*(mValue + 8f);
                }
                Single num2 = _beamLength - 1f;
                _beam.transform.localScale = new Vector3(num2, 1f, 1f);
                _beamImpact.transform.position = _beam.transform.position + _forwards*num2;
            }
            else
            {
                if (mDistanceToPlayer < 68f)
                {
                    if (_found)
                    {
                        Single num3 = UnityEngine.Random.Range(0.4f, 0.8f);
                        _beamImpact.transform.localScale = new Vector3(num3, num3, num3);
                    }
                    else
                    {
                        _beamImpact.transform.localScale = new Vector3(0.15f, 0.15f, 0.15f);
                    }
                }
                // Beam intensity should be about .05 when output is 0, and should scale 1 to 255 linearly over .1 to 1.
                Single beamIntensity = (_output == 0 ? -14 : _output)/(255f/0.9f) + 0.1f;
                _beam.transform.localScale = new Vector3(_beamLength - 1f, beamIntensity, beamIntensity);
                _impactLight.intensity = beamIntensity*2f;
                _impactLight.gameObject.SetActive(beamIntensity > 0.1f);
            }
            if (_impactPosition.x != -999f)
            {
                _impactPosition.x = _impactPosition.x + 0.5f;
                _impactPosition.y = _impactPosition.y + 0.5f;
                _impactPosition.z = _impactPosition.z + 0.5f;
                SurvivalParticleManager.instance.LPTImpactFailEffect.transform.position = _impactPosition;
                SurvivalParticleManager.instance.LPTImpactFailEffect.Emit(50);
                _impactPosition.x = -999f;
            }
        }

        public override void UnitySuspended()
        {
            _beam = null;
            _beamImpact = null;
            _impactLight = null;
        }

        private void UpdateRotation(Byte flags)
        {
            _found = false;
            _searchDist = MinSearchDist;

            _forwards = SegmentCustomRenderer.GetRotationQuaternion(flags)*Vector3.forward;
            _forwards.Normalize();
            _xOffset = (SByte) _forwards.x;
            _yOffset = (SByte) _forwards.y;
            _zOffset = (SByte) _forwards.z;

            if (_xOffset > 0)
                _targetDirection = 0x10;
            else if (_xOffset < 0)
                _targetDirection = 0x20;
            else if (_yOffset > 0)
                _targetDirection = 0x02;
            else if (_yOffset < 0)
                _targetDirection = 0x01;
            else if (_zOffset > 0)
                _targetDirection = 0x08;
            else if (_zOffset < 0)
                _targetDirection = 0x04;
            else // Shouldn't happen, log a warning and set to 0
            {
                Debug.LogWarning("Logic Laser x, y, and z offset zero? Flags: " + flags);
                _targetDirection = 0;
            }
        }
    }
}
