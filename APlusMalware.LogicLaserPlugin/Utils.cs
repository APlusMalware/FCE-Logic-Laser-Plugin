using System;
using UnityEngine;

namespace APlusMalware.LogicLaserPlugin
{
    public static class Utils
    {
        public static void FlagsToRelativeForward(Byte flags, out SByte x, out SByte y, out SByte z)
        {
            var v = SegmentCustomRenderer.GetRotationQuaternion(flags) * Vector3.forward;
            x = (SByte)v.x;
            y = (SByte)v.y;
            z = (SByte)v.z;
        }

        public static void FlagsToRelativeLeft(Byte flags, out SByte x, out SByte y, out SByte z)
        {
            var v = SegmentCustomRenderer.GetRotationQuaternion(flags) * Vector3.left;
            x = (SByte)v.x;
            y = (SByte)v.y;
            z = (SByte)v.z;
        }

        public static void FlagsToRelativeUp(Byte flags, out SByte x, out SByte y, out SByte z)
        {
            var v = SegmentCustomRenderer.GetRotationQuaternion(flags) * Vector3.up;
            x = (SByte)v.x;
            y = (SByte)v.y;
            z = (SByte)v.z;
        }

        public static Byte CalcOppositeFace(Byte face)
        {
            if ((face & 0x15) != 0)
                return (Byte)(face << 1);
            return (Byte)(face >> 1);
        }

        public static Byte CalcFrontFace(Byte flags)
        {
            byte rotation = (byte)(flags >> 6);
            byte orientation = (Byte)(flags & 63);
            byte face;
            if ((rotation & 1) != 0)
            {
                if ((orientation & 13) != 0)
                {
                    face = 16;
                }
                else if ((orientation & 2) != 0)
                {
                    face = 32;
                }
                else if ((orientation & 22) != 0)
                {
                    face = 1;
                }
                else
                {
                    face = 2;
                }
            }
            else if ((orientation & 51) != 0)
            {
                face = 4;
            }
            else if ((orientation & 8) != 0)
            {
                face = 1;
            }
            else
            {
                face = 2;
            }
            if ((rotation & 2) != 0)
            {
                return CalcOppositeFace(face);
            }
            return face;
        }

        public static Byte CalcBackFace(Byte flags)
        {
            return CalcOppositeFace(CalcFrontFace(flags));
        }

        public static Byte CalcRightFace(Byte flags)
        {
            return CalcFrontFace(CubeHelper.RotateFlags(flags, true));
        }

        public static Byte CalcLeftFace(Byte flags)
        {
            return CalcFrontFace(CubeHelper.RotateFlags(flags, false));
        }

        public static Byte CalcTopFace(Byte flags)
        {
            Byte orientation = (Byte)(flags & CubeHelper.FACEMASK);
            return orientation;
        }

        public static Byte CalcBottomFace(Byte flags)
        {
            return CalcOppositeFace(CalcTopFace(flags));
        }
    }
}
