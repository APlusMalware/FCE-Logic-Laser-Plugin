using System;
using UnityEngine;

namespace APlusMalware.LogicLaserPlugin
{
    public static class Utils
    {
        public static void FlagsToRelativeForward(Byte flags, out SByte x, out SByte y, out SByte z)
        {
            var v = SegmentCustomRenderer.GetRotationQuaternion(flags) * Vector3.forward;
            x = (SByte)v.x;
            y = (SByte)v.y;
            z = (SByte)v.z;
        }

        public static void FlagsToRelativeLeft(Byte flags, out SByte x, out SByte y, out SByte z)
        {
            var v = SegmentCustomRenderer.GetRotationQuaternion(flags) * Vector3.left;
            x = (SByte)v.x;
            y = (SByte)v.y;
            z = (SByte)v.z;
        }

        public static void FlagsToRelativeUp(Byte flags, out SByte x, out SByte y, out SByte z)
        {
            var v = SegmentCustomRenderer.GetRotationQuaternion(flags) * Vector3.up;
            x = (SByte)v.x;
            y = (SByte)v.y;
            z = (SByte)v.z;
        }

        public static Byte CalcOppositeDirection(Byte face)
        {
            if ((face & (CubeHelper.TOP | CubeHelper.NORTH | CubeHelper.EAST)) != 0)
                return (Byte)(face << 1);
            return (Byte)(face >> 1);
        }

        public static Byte CalcFrontDirection(Byte flags)
        {
            Byte rotation = (Byte)(flags >> 6);
            Byte orientation = (Byte)(flags & 63);
            Byte face;
            // I think I used a K-map to figure this all out? But, it does work, somehow.
            // The magic numbers are, in fact, magic.
            if ((rotation & 1) != 0) // 01
            {
                if ((orientation & 13) != 0) // 001101
                {
                    face = CubeHelper.WEST;
                }
                else if ((orientation & 2) != 0) // 000010
                {
                    face = CubeHelper.EAST;
                }
                else if ((orientation & 22) != 0) // 010110
                {
                    face = CubeHelper.TOP;
                }
                else // 100000
                {
                    face = CubeHelper.BOT;
                }
            }
            else if ((orientation & 51) != 0) // 110011
            {
                face = CubeHelper.NORTH;
            }
            else if ((orientation & 8) != 0) // 001000
            {
                face = CubeHelper.TOP;
            }
            else // 000100
            {
                face = CubeHelper.BOT;
            }
            if ((rotation & 2) != 0) // 10
            {
                return CalcOppositeDirection(face);
            }
            return face;
        }

        public static Byte CalcBackDirction(Byte flags)
        {
            return CalcOppositeDirection(CalcFrontDirection(flags));
        }

        public static Byte CalcRightDirection(Byte flags)
        {
            return CalcFrontDirection(CubeHelper.RotateFlags(flags, true));
        }

        public static Byte CalcLeftDirection(Byte flags)
        {
            return CalcFrontDirection(CubeHelper.RotateFlags(flags, false));
        }

        public static Byte CalcTopDirection(Byte flags)
        {
            Byte orientation = (Byte)(flags & CubeHelper.FACEMASK);
            return orientation;
        }

        public static Byte CalcBottomDirection(Byte flags)
        {
            return CalcOppositeDirection(CalcTopDirection(flags));
        }
    }
}
